<!DOCTYPE html>
<html>
<head>
    <title>wok</title>
<link href="tipsy.css" rel="stylesheet" type="text/css" /> 
<style type="text/css">
body {
  font: 10px sans-serif;
}
.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: "Helvetica";
    font-size: 8px;
}
.line {
    stroke-width:.1px;
    fill: none;
    stroke: black;
}
</style>
</head>
<body>
<script src="js/d3.min.js"></script>
<script src="js/jquery-1.7.2.min.js"></script>
<script src="js/jquery.tipsy.js"></script>
<script type="text/javascript">
var svg;

var xScale;
var xAxis;
var straightLine = [];
var years = [];
var uniqueYears;
var uniqueAuthors;
var uniqueKeywords;
var journalTypes = [];
var authors = [];
var keywords = [];
var goSecond = false;

var totals = [];
var totalAuthors = [];
var totalKeywords = [];

var total1 = 0;

var color =  d3.scale.category20c();
var opacityMap;

var firstLoadVar;
var firstLoad = -1;
var secLoad = -1;

var padding = 35;

var minYear;
var maxYear;
var maxAuthor;
var thisTotal;
var eachPaper;

var heightScale;
var singleScale;
var thisData = [];
var theseAuthors = [];
var theseKeywords = [];
var theX = [];
var maxEntries;
var width = 1400;
var height = 720;

d3.csv("memory_allyears_smallBatch.csv", function(data) {
        thisData=(data);
    for (i = 0;i<thisData.length; i++){ 
        years[i] = data[i].Year;
        authors[i] = data[i].Authors.split("., ");
        for (j=0; j<authors[i].length; j++){
        theseAuthors.push(authors[i][j]);            
        }
        journalTypes[i] = data[i].Sourcetitle;
    }


////finds unique names etc
    function onlyUnique(value, index, self) { 
        return self.indexOf(value) === index;
    } 
    uniqueTypes = journalTypes.filter( onlyUnique ); //finds unique names
    uniqueYears = years.filter( onlyUnique ); //finds unique names

////consolidates the Value for all values of a given Name
    function valueConsolidation(givenYear, i) { 
        var total = 0;
        for (i = 0;i<data.length; i++){ 
            if(data[i].Year== givenYear){
                total++;
            }else{
            }}
         return total;
     } 
 //creates a new aray with the sums of all the different Names 
    for (i = 0; i<uniqueYears.length; i++){
        totals[i]= valueConsolidation(uniqueYears[i])
    } 

svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

   maxAuthor = d3.max(totalAuthors, function(d) { return d; });
   singleScale = d3.scale.linear()
        .domain([1, maxAuthor*5])
        .range([1, height/6-100]);

    maxEntries = d3.max(totals, function(d) { return d; });

    minYear = d3.min(years, function(d) { return d; });
    maxYear = d3.max(years, function(d) { return d; });

    xScale = d3.scale.linear()
        .domain([minYear, maxYear]) //not min year to max year
        .range([61, width-65]);

    var maxCited = d3.max(data, function(d) { return d.Cited; });
    opacityMap = d3.scale.linear()
        .domain([0, maxCited])
        .range([.2, 1])        

    heightScale = d3.scale.linear()
        .domain([0, maxEntries*3])
        .range([padding, height/1.2]);


////FOR X AXIS
// var xTime = d3.time.scale()
//     .domain([new Date(1965,7,1), new Date(2014,7,1)])
//     .range([65, w-46]);

// xAxis = d3.svg.axis()
//     .scale(xTime)
//     .ticks(d3.time.years)
//     .tickSize(6,0)
//     .orient("bottom");

// svg.append("g")
//     .attr("class", "axis")  //Assign "axis" class
//     .attr("transform", "translate(0," + (h - padding+5) + ")")
//     .call(xAxis);

    eachPaper = svg.selectAll("theseRects")
        .data(data)
        .enter()
        .append("rect");
    eachPaper
        .attr("class", function(d,i){
            theX.push(xScale(d.Year));
            for (j = 0; j<uniqueYears.length; j++){
                if (d.Year==uniqueYears[j]){
                    return "theseRects"+uniqueYears[j];               
                }
            }
        })
        .attr("x", function(d,i) {
            return  xScale(d.Year);               
         })
        .attr("y", function(d,i){
                     //if your year matches the unique name year
                     //go through the unique name year's total at index of unique name
                     // map on the y region according to this
            for (j = 0; j<uniqueYears.length; j++){
                if (d.Year==uniqueYears[j]){
                    return ((height)-heightScale(totals[j]));               
                }
            }
            })
        .attr("width", 20)
        .attr("height", 5)
        .attr("stroke-width",.5);

$('rect').tipsy({
    gravity: 'w', 
    html: true, 
    delayIn: 500, 
    title: function() {
        var d = this.__data__;     
        var whichCited;
        if (d.Cited>0){
            whichCited = d.Cited;
        } 
        else {
            whichCited = 0;
        }
        return d.Year+" "+", Journal: "+d.Sourcetitle+"<br/>Cited by "+whichCited+" other sources"+"<br/>Author: "+d.Authors;         
    }
});



firstLoadVar = setInterval(function(){ 
if(totals.length>0){    
    if (firstLoad<totals.length-1){
        firstLoad++; 
        if (firstLoad>=0){
            total1=0;
            prep(firstLoad, totals[firstLoad], uniqueYears[firstLoad]); //store inner subjects is the loading function for the big data      
        }
    }
    else {
    console.log(journalTypes.length)
    clearInterval(firstLoadVar); //and stop loading stuff in
    }
}
},100);  
})

var b=0;
$("body").keypress(function(){
    (b+=1);
    if (b==1){
        for (i=0; i<thisData.length; i++){
            straightLine.push([theX[i], theHeight[i]]);    
        }
    }
    if (b==2){
        addLines();
    }
    if (b==3){
        goRandom();
    }
  });



var theHeight = [];
function prep(z,tots, thisYear){
if(totals.length>0){    
d3.selectAll(".theseRects"+thisYear)
    .transition()
    .attr('y', function(d,i) {
        if (d.Year==thisYear){
            total1++;
            theHeight.push((height)-heightScale(total1*3))                     
            return (height)-heightScale(total1*3);   
        }
    })
    .attr("fill", function(d,i){

        for (j=0; j<uniqueTypes.length; j++){
            if(d.Sourcetitle==uniqueTypes[j]){
               return color(j);
            }       
        }   
    })
    .attr("opacity", function(d,i){
        return opacityMap(d.Cited);
    })
}
}


var line = d3.svg.line()
    .interpolate("cardinal") //cardinal is cool also monotone
    .x(function(d, i) { 
        return d[0];
    })
    .y(function(d, i) { 
        return d[1];
    });

function addLines(){
var thisd = [1];
var people = svg.selectAll(".people")
    .data(thisd);    
people
    .enter()
    .append("g")
    .attr("class", "people")
    .append("path")
    .attr("class", "line")
    .attr("d", function(d){
        return line(straightLine);
    });

}
function goRandom(){
console.log("random")
straightLine.length = 0;
var newLine = [];
newLine.push([0,height]);

d3.selectAll("path.line")
.transition()
.attr("d", function(d){
    return line(newLine);
})



var newX = [];
var newY = [];
var randomX = d3.scale.linear()
    .domain([0,1]) 
    .range([padding, width-padding]);
var randomY = d3.scale.linear()
    .domain([0,1]) 
    .range([padding, height-padding]);


for (i=0; i<thisData.length; i++){
    newX.push(randomX(Math.random()))
    newY.push(randomY(Math.random()))
}
for (i=0; i<thisData.length; i++){
    straightLine.push([newX[i], newY[i]]); 
}

if (straightLine.length==thisData.length){
d3.selectAll("rect")
    .transition()
    // .duration(3000)
    .attr("x", function(d,i){
        return randomX(Math.random());
    })
    .attr("y", function(d,i){
        return randomY(Math.random());
    })
    .attr("width",1)
    .attr("height",1);
eachNode = svg.selectAll("nodeCircs")
    .data(thisData)
    .enter()
    .append("circle")
    .attr("class", function(d,i){
        for (j = 0; j<uniqueYears.length; j++){
            if (d.Year==uniqueYears[j]){
                return "nodeCircs"+uniqueYears[j];               
            }
        }
    })
    .attr("fill", "none")
    .attr("stroke","none")
    .attr("cx",function(d,i){
        return xScale(d.Year)
    })
    .attr("cy",function(d,i){
        for (j = 0; j<uniqueYears.length; j++){
            if (d.Year==uniqueYears[j]){
                return ((height)-heightScale(totals[j]));               
            }
        }
    })
    .attr("r",0)
    .transition()
    .attr("cx", function(d,i){
        return newX[i];
    })
    .attr("cy", function(d,i){ 
        return newY[i];
    })
    .attr("r", function(){
        return 5;        
    })
    .attr("fill", function(d,i){
        for (j=0; j<uniqueTypes.length; j++){
            if(d.Sourcetitle==uniqueTypes[j]){
               return color(j);
            }       
        }
    });
d3.selectAll("path.line")
.transition()
.attr("d", function(d){
    return line(straightLine);
})   
    .each("end", function(){
        d3.selectAll("rect")
            .transition()
            .attr("width",.1)
            .attr("height",.1)
    })
}

$('circle').tipsy({
    gravity: 'w', 
    html: true, 
    delayIn: 500, 
    title: function() {
        var d = this.__data__;     
        var whichCited;
        if (d.Cited>0){
            whichCited = d.Cited;
        } 
        else {
            whichCited = 0;
        }
        return d.Year+" "+", Journal: "+d.Sourcetitle+"<br/>Cited by "+whichCited+" other sources"+"<br/>Author: "+d.Authors;         
    }
});

}

</script>
</body>
</html>