<!DOCTYPE html>
<html>
<head>
	<title>wok</title>
<link href="tipsy.css" rel="stylesheet" type="text/css" /> 

	<style type="text/css">
	</style>
</head>
<body>
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="js/jquery.tipsy.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<div id = "thing"></div>

<script type="text/javascript">

var years = []
var uniqueYears;
var totals = [];
var huh = [];
var total1 = 0;
var total2 = 0;
var total3 = 0;
var total4 = 0;
var total5 = 0;
var total6 = 0;
var totalss = {};
var firstLoadVar;
var firstLoad = -1;
var thisTotal;
var totalsCircles;
    //Width and height
    var w = 1400;
    var h = 800;
	d3.csv("smallcsv.csv", function(data) {
		// console.log(data);
    for (i = 0;i<data.length; i++){ 
        years[i] = data[i].Year;
    } //generates an array of all Names



    function onlyUnique(value, index, self) { 
        return self.indexOf(value) === index;
    } 
    uniqueYears = years.filter( onlyUnique ); //finds unique names
    console.log("Unique Years: " + uniqueYears);

    function valueConsolidation(givenYear, i) { 
    //consolodates the Value for all values of a given Name
        var total = 0;
        for (i = 0;i<data.length; i++){ 
            if(data[i].Year == givenYear){
                total++;
            }else{
            }}
         return total;
     } 
    console.log("Sum of All 1996's: " + valueConsolidation("1996"))
 
    for (i = 0; i<uniqueYears.length; i++){
        totals[i]= valueConsolidation(uniqueYears[i])
    } //creates a new aray with the sums of all the different Names




    
    var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);
    
 //    var maxEntries = d3.max(totals, function(d) { return d; });
	// 		//Create scale functions
	// var radiusScale = d3.scale.linear()
	// 	.domain([0, maxEntries])
	// 	.range([1, 100]);
			//Create scale functions
	// var xScale = d3.scale.linear()
	// 	.domain([0, totals.length])
	// 	.range([10, w-10]);
	var xScale = d3.scale.linear()
		.domain([1984, 2014])
		.range([100, w-100]);
	// var yScale = d3.scale.linear()
	// 	.domain([1984, 2014])
	// 	.range([10, h-10]);
    // var yScale = d3.scale.linear()
    //     .domain([0, maxEntries])
    //     .range([h/2, h/4]);

    // var yScale = d3.scale.linear()
    //     .domain([0, maxEntries])
    //     .range([h/2, h/4]);
// if(huh.length>0){
    totalsCircles = svg.selectAll("theseRects")  //draw circles with the newly parsed data values, the scale difference makes it weird!
                    .data(data)
                    .enter()
                    .append("rect");
                totalsCircles
                    .attr("class", function(d,i){
    for (j = 0; j<uniqueYears.length; j++){
        if (d.Year==uniqueYears[j]){
             return "theseRects"+uniqueYears[j];               
        }
}









})
                    .attr("x", function(d,i) {
                        return  xScale(d.Year);
                    })
                    .attr("y", function(d,i){
                     //if your year matches the unique name year
                     //go through the unique name year's total at index of unique name
                     // map on the y region according to this
    for (j = 0; j<uniqueYears.length; j++){
        if (d.Year==uniqueYears[j]){
             return h/1.2-10*totals[j];               
// return i;
        }
}

})
                    // if(d.Year==1984){
                    //     total1++;
                    //     return (h/1.2)-10*total1;                        
                    //  }
                    // if(d.Year==1985){
                    //     total2++;
                    //     return (h/1.2)-10*total2;   
                    // }
                    // if(d.Year==1986){
                    //  return (h/1.2)-10*i;                        
                    //  }
                    // if(d.Year==1987){
                    //  return (h/1.2)-10*i;                        
                    //  }
                    // })
                    .attr("width", 10)
                    .attr("height", 10)
                     .attr("fill", "grey")
                     .attr("opacity",.3)
$('rect').tipsy({

        gravity: 'w', 
        html: true, 
        delayIn: 500, 
        title: function() {
          var d = this.__data__;      
         return d.Year;         
        }
      });



firstLoadVar = setInterval(function(){ 
if(totals.length>0){    
    if (firstLoad<totals.length-1){
        // d3.tsv("connectionfreqcodes_top25.txt", function(error, cData) {
        firstLoad++; 
        if (firstLoad>=0){
            // thisTotal = totals[firstLoad];
           // agh(1, totals[1], uniqueYears[1]); 
            total1=0;

           agh(firstLoad, totals[firstLoad], uniqueYears[firstLoad]); //store inner subjects is the loading function for the big data      
        }
        // })
    }
    else {
    // runOnce(); //once you have loaded everything in, then run the visual elements
    clearInterval(firstLoadVar); //and stop loading stuff in
    }
}
},500);   










		})



function agh(z,tots, thisYear){
if(totals.length>0){	
console.log("yes")
console.log(z)
console.log(tots)
d3.selectAll(".theseRects"+thisYear)
// totalsCircles
    .transition()
    .attr('y', function(d,i) {

    // for (j = 0; j<uniqueYears.length; j++){
        if (d.Year==thisYear){
                    // if(d.Year==1984){
                        total1++;
                        return (h/1.2)-20*total1;                        
                     }
        //     for (k=0; k<tots; k++){ //j is in unique years
        //         console.log(k);
        //     }    
        // }
        // return h/1.2-k;                    


})		 
}
}

</script>
</body>
</html>